{"/concepts/action-handler":{"title":"Action Handler","data":{"":"üìù NOTE:\nFor example project structure reference, click here"}},"/concepts":{"title":"Index","data":{"":"üìù NOTE: If you're already familiar with the routing and middleware\npatterns, feel free to skip this page and start from\nhere\nIf you're looking for compatibility and installation guide then head over to\nhereGo through the concepts page by page in order and top to bottom on each page\nto get good understanding of the concepts. Skip only when you already know the concept.\nThis won't take you long. If you've already user nextjs server actions and have some understanding\nof express like routing and middleware pattern then this shouldn't take you more than\n10-15 mins.","file-conventions#File Conventions":"All the code examples in this documentation use nextjs v14 app router\nwithout src directory. You're absolutely free to use src directory or\neven organize your files as you see fit.\nFor reference: Example Project structure\nmy-nextjs-app/\n‚îú‚îÄ‚îÄ .next/\n‚îú‚îÄ‚îÄ ...\n‚îú‚îÄ‚îÄ app/\n‚îÇ ‚îú‚îÄ‚îÄ actions/ <- exportable server actions will go here\n‚îÇ ‚îú‚îÄ‚îÄ ...\n‚îÇ ‚îú‚îÄ‚îÄ page.tsx\n‚îú‚îÄ‚îÄ components/\n‚îú‚îÄ‚îÄ lib/  <- We'll keep action router here\n‚îú‚îÄ‚îÄ ...\n‚îú‚îÄ‚îÄ tsconfig.json\n‚îî‚îÄ‚îÄ README.md","how-action-routing-works#How action routing works?":"The basic idea behind action routing is simple. The action router\nlets you define a request-response lifecycle for any action request.\nYou can choose to create a single action router per project or create\nmultiple incrementally as needed.\nA picture is worth a thousand words"}},"/concepts/input-validation":{"title":"Input Validation","data":{"":"üìù NOTE:\nFor example project structure reference, click here"}},"/examples":{"title":"Index","data":{}},"/":{"title":"A little background","data":{"":"I've had experience building with Strapi and Express.js,\nand what I really loved about both projects is their routing\nand middleware systems.These patterns offer several benefits, including:\nEnhanced code readability\nIncreased modularity\nCleaner API syntax\nMore robust implementations\nMaximum code reusability\nWith the introduction of server actions in Next.js,\nwriting APIs has become much easier.\nHowever, the advanced routing and middleware patterns\nI valued in Strapi and Express.js are still not natively supported by Next.js.A few months ago, when I started building a full-stack e-commerce website,\nI quickly realized the need for these abstractions.\nUnfortunately, I couldn't find any simple and useful solutions.\nSo, I created a bare minimum implementation of this library for my project.\nDrawing on the lessons and ideas from that draft implementation,\nI developed this library with more advanced, type-safe features.I've got more ideas but for now let's get started!","aim#Aim":"This library aims to simplify working with nextjs server actions. One can easily\ncompose complex server actions using the provided abstractions.","features#Features":"‚úÖ Action Routing\n‚úÖ Error Code management\n‚úÖ Error Handling\n‚úÖ Input Validation\n‚úÖ Light weight\n‚úÖ Middleware Support\n‚úÖ Snappy DX\n‚úÖ Supports both js/ts projects\n‚úÖ Type Safety"}},"/installation":{"title":"Installation","data":{"compatibility#Compatibility":"Current version is only tested for nextjs v14 (app router). Both javascript and typescript projects written\nin nextjs v14 are Compatible. Support for nextjs v13 and v15 will roll out sooner.\nRequirements:\nNext.js ^14\nReact >= 18.2.0\nTypeScript >= 5\nZod","required-dependencies#Required dependencies":"Since next-server-action uses zod for input validation.\nSo make sure to install zod in your project.\nnpm install zod\nOR\npnpm install zod","final-installation#Final Installation":"npm install next-server-action\nOR\npnpm install next-server-action\nNow, you're all set to compose actions for your project but before that\nI encourage you to go though the concepts to get the working understanding\nof the library abstractions."}},"/types":{"title":"Types","data":{}},"/concepts/action-routing":{"title":"Action Router","data":{"":"ActionRouter is the main component behind all this magic ‚ú®. This creates\nan entry point for the associated action request. In simple words, the server actions\nwhich are defined on a particular instance of ActionRouter will start their execution\njourney from that router instance.\nüìù NOTE:\nFor example project structure reference, click here","quick-initalization#Quick initalization":"// lib/action.router.ts\nimport { ActionRouter } from \"next-server-action/server\";\n// let's call this as root router\nexport const rootRouter = new ActionRouter();\nThis is enough to get you started with the action routing\nbut there's a slightly better way to initalize the router instance\nif you want to have type inference for error codes in your react client\ncomponents. Don't worry\nif didn't get the point, you'll get it just keep reading.","better-initalization-optional#Better Initalization (optional)":"// lib/action.router.ts\nimport { ActionRouter } from \"next-server-action/server\";\n// let's call this as root router\nexport const rootRouter = new ActionRouter({\n  error: {\n    // predefined error codes at router instance level\n    codes: {\n      unauthorized: \"You are unauthorized\",\n      \"not-found\": \"Requested resource not found\",\n      \"rate-limit-exceeded\":\n        \"Rate limit exceeded. please try again after some time\",\n    },\n  },\n});\nWhile initalizing router instance, you can define all the error codes\nwhich can be used to return descriptive error messages to the client and\ncool thing about this is error codes are inferred everywhere even\non the react components. This is really helpfull to write more robust\ncomponents and enhance user experience. This is really cool, I just love ‚ù§Ô∏è it!"}},"/concepts/middlewares":{"title":"Action Middlewares","data":{"":"Technically, All middleware types have same signature and they all serves\nthe same purpose. The category of middleware gets decided on how you setup the logic flow (aka. action routing chain).You can register a action middleware function by calling use method on your action router\ninstance and providing a function that return promise of context.Execution Order: Middlewares get executed in the order in which they are chained together.\nüìù NOTE:\nFor example project structure reference, click here\nThere are three different category of middlewares that you can\nregister on a action router instance.\nGlobal middlewares\nSub-Router middlewares\nServer action level middlewares\nLet's explore each of them one by one!","middleware-function#Middleware function":"As I mentioned it above, there's no technical difference between the middleware categories. Regardless,\nwhat you call it under the hood they have same signature, purpose and constraints.For type definitions click here.Every middleware will receieve an object of type ActionRequest as argument containing\nthe context, cookies and headers for the running action request.\nimport { cookies, headers } from \"next/headers\";\ntype ActionRequest<TContext> = {\n  context: TContext;\n  headers: ReturnType<typeof headers>;\n  cookies: ReturnType<typeof cookies>;\n};\ntype ActionMiddleware<TContext, TReturn> = (\n  request: ActionRequest<TContext>\n) => Promise<TReturn>;\nCaveat: All the chained middleware functions must need to return a context\nonce they're done executing their logic. This is important and helpful to extend\nthe context object as the action requests progresses from one root to the\nfinal action handler. Even if you're not mutating the context then just returned the\noriginal context.The returned value can only be a primitive object. Like Array, Map, etc are not allowed.\nThe returned value from a middleware will serve as context for the next chained middleware.Default context: { inputs: null }","global-middlewares#Global Middlewares":"In short, The middlewares registered at the very root of the router instance are called as\nglobal Middlewares and they will run for every single action request hitting the same router instance.\nUseCase: Request logging, rate limiting, auth check, etc\n// lib/action.router.ts\nimport { ActionRouter } from \"next-server-action/server\";\nexport const rootRouter = new ActionRouter({\n  // router config\n})\n  .use(async ({ context }) => {\n    console.log(\"Global middleware 1\");\n    return context;\n  })\n  .use(async ({ context }) => {\n    console.log(\"Global middleware 2\");\n    return context;\n  })\n  .use(async ({ context }) => {\n    console.log(\"Global middleware 3\");\n    return context;\n  });","sub-router-middlewares#Sub-Router middlewares":"Now let's say you have two different resources in your application like blogs and products.\nYou want to run some specific code for all the blogs related server actions but not for products related server actions,\nwe can call that specific code as sub action router level middleware.We need two more sub action routers for blog and product server actions.\nCreating a sub-router is as simple as re-assigning the current action router\ninstance to a new variable. For mental model, you can think of it as a tree starting\nfrom root and then branching off in different directions as needed.\nI call this as branching the action router. Anyways, you get the point!\n// lib/action.router.ts\nimport { ActionRouter } from \"next-server-action/server\";\nexport const router = new ActionRouter({\n  // router config\n})\n  .use(async ({ context }) => {\n    console.log(\"Global middleware 1\");\n    return context;\n  })\n  .use(async ({ context }) => {\n    console.log(\"Global middleware 2\");\n    return context;\n  })\n  .use(async ({ context }) => {\n    console.log(\"Global middleware 3\");\n    return context;\n  });\n// branching off from root router\nexport const blogsRouter = rootRouter\n  .use(async ({ context }) => {\n    console.log(\"Blog middleware 1\");\n    return context;\n  })\n  .use(async ({ context }) => {\n    console.log(\"Blog middleware 2\");\n    return context;\n  })\n  .use(async ({ context }) => {\n    console.log(\"Blog middleware 3\");\n    return context;\n  });\n// branching off from root router\nconst productsRouter = router\n  .use(async ({ context }) => {\n    console.log(\"Product middleware 1\");\n    return context;\n  })\n  .use(async ({ context }) => {\n    console.log(\"Product middleware 2\");\n    return context;\n  })\n  .use(async ({ context }) => {\n    console.log(\"Product middleware 3\");\n    return context;\n  });\nIf a action request hits this action router.\nThen here's the execution order output\nGlobal middleware 1\nGlobal middleware 2\nGlobal middleware 3","server-action-level-middlewares#Server action level middlewares":"To be honest, in most cases this might be an over kill but can be helpful\nin situations like where you want to reuse the existing action middleware. That's all!Unlike the root/global middlewares, the middlewares which are registered very close\nthe to final action handler can be called as method/server action level middleware.Example: for your blogs resource, you are implementing a deleteBlog method and you want\nrun a middleware that check if the caller have right permission to delete the requested blog.\n// app/actions/index.ts\n\"use server\";\nimport { blogsRouter, productsRouter } from \"@/lib/action.router.ts\";\nexport const deleteBlog = blogsRouter\n  .use(async ({ context }) => {\n    // ... some code to check if caller is allowed\n    console.log(\"Delete blog server action middleware 1\");\n    return context;\n  })\n  .run(async () => {\n    // final action handler\n  });\nexport const deleteProduct = productRouter\n  .use(async ({ context }) => {\n    // similarly, you can register any middleware here\n    // which only run for this server action method.\n    console.log(\"Delete product server action middleware 1\");\n    return context;\n  })\n  .run(async () => {\n    // final action handler\n  });\nNothing to worry about, run method we'll cover this method soon.","final-execution-order#Final Execution Order":"If client invokes deleteBlog server action. The following will be order:\nGlobal middleware 1\nGlobal middleware 2\nGlobal middleware 3\nBlog middleware 1\nBlog middleware 2\nBlog middleware 3\nDelete blog server action middleware 1\nIf client invokes deleteProduct server action. The following will be order:\nGlobal middleware 1\nGlobal middleware 2\nGlobal middleware 3\nProduct middleware 1\nProduct middleware 2\nProduct middleware 3\nDelete product server action middleware 1"}},"/usage":{"title":"Basic Usage","data":{"":"// app/actions/blogs.ts\n\"use server\";\nimport { router } from \"@/lib/action.router.ts\";\n// fake blogs\nconst blogs = [\n  {\n    id: 1,\n    title: \"Blog 1\",\n  },\n  {\n    id: 2,\n    title: \"Blog 2\",\n  },\n];\nexport const findAllBlogs = router.run(async (request, response) =>\n  response.data(blogs)\n);\n\"use client\";\nimport { findAllBlogs } from \"@/app/actions/blogs.ts\";\nconst Button = () => (\n  <button\n    onCLick={async () => {\n      const response = await findAllBlogs();\n      if (response.success) {\n        console.log(response.data);\n      } else {\n        console.error(response.error);\n      }\n    }}\n  >\n    Blogs\n  </button>\n);"}}}